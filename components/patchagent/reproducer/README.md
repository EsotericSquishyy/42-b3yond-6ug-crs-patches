# Reproducer

The Reproducer component is a critical part of the PatchAgent system that validates the effectiveness of generated patches by reproducing vulnerability proof-of-concepts (PoCs) against patched code.

## Overview

For each patch generated by PatchAgent, the Reproducer systematically tests whether the patch successfully fixes all related vulnerabilities within the same task. It operates on a hierarchical structure:

```
Task
├── BugProfile (vulnerability type)
│   ├── Patch (AI-generated fix)
│   └── BugGroup (collection of similar bugs)
│       └── Bug (individual vulnerability instances)
│           └── PoC (proof-of-concept)
```

## Purpose

The Reproducer serves several key functions:

1. **Patch Validation**: Verifies that generated patches actually fix the intended vulnerabilities
2. **Cross-Profile Testing**: Tests patches against bugs from different bug profiles within the same task
3. **Regression Prevention**: Ensures patches don't break existing functionality
4. **Quality Assurance**: Provides confidence metrics for patch effectiveness

## Architecture

### Core Components

#### `reproduce.py`
The main orchestrator that:
- Continuously monitors for tasks in `processing` or `waiting` status
- Coordinates patch reproduction across all bug profiles within a task
- Manages the reproduction workflow and database updates

#### `build_utils.py`
Provides building and testing infrastructure:
- **ReproBuilder**: Extends OSSFuzzBuilder for reproduction-specific functionality
- **Build Management**: Handles Docker container creation and build processes
- **PoC Replay**: Executes proof-of-concepts against patched binaries

### Data Flow

1. **Task Discovery**: Queries database for active tasks
2. **Patch Collection**: Gathers available patches for each bug profile
3. **Cross-Profile Testing**: Tests each patch against bugs from other profiles
4. **Build Process**: Creates patched binaries using OSS-Fuzz infrastructure
5. **PoC Execution**: Replays vulnerability PoCs against patched code
6. **Result Recording**: Stores success/failure status in `patch_bugs` table

## Key Features

### Intelligent Caching
- **Build Caching**: Avoids rebuilding identical patches using hash-based workspaces
- **Edge Tracking**: Maintains `already_built_edge` set to prevent redundant work
- **Database Sync**: Synchronizes with existing `PatchBug` entries on startup

### Batch Processing
- **Efficient Testing**: Processes multiple bugs per patch to maximize throughput
- **Resource Optimization**: Limits bug queries to 1000 per batch
- **Randomized Ordering**: Uses random ordering to distribute load evenly

### Error Handling
- **Docker Failures**: Gracefully handles Docker unavailability
- **Build Errors**: Catches and reports build process failures
- **Timeout Management**: Implements timeouts for long-running operations

## Database Schema

### Core Tables

#### `patch_bugs`
Stores the results of patch testing:
```sql
CREATE TABLE patch_bugs (
    id SERIAL PRIMARY KEY,
    patch_id INTEGER REFERENCES patches(id),
    bug_id INTEGER REFERENCES bugs(id),
    repaired BOOLEAN NOT NULL,
    UNIQUE(bug_id, patch_id)
);
```

#### Related Tables
- **`patches`**: Generated patches from bug profiles
- **`bugs`**: Individual vulnerability instances with PoCs
- **`bug_profiles`**: Grouped vulnerabilities by type
- **`tasks`**: Top-level task containers

## Usage

### Running the Reproducer

```bash
# Start the reproducer service
python reproduce.py
```

The reproducer runs continuously, checking for new tasks every 20 seconds.

### Environment Requirements

The reproducer requires:
- **Docker**: For building and running OSS-Fuzz containers
- **Database Access**: PostgreSQL connection for task and patch data
- **File System**: Access to `/reproducer` workspace directory
- **Network**: Access to download source code and tooling

### Configuration

## Sanitizer Support

The reproducer supports multiple sanitizers:
- **AddressSanitizer (ASAN)**: Memory corruption detection
- **MemorySanitizer (MSAN)**: Uninitialized memory detection  
- **UndefinedBehaviorSanitizer (UBSAN)**: Undefined behavior detection
- **LeakSanitizer (LSAN)**: Memory leak detection
- **Jazzer**: Java-specific fuzzing and sanitization

## Performance Considerations

### Optimization Strategies
- **Parallel Builds**: Multiple patches can be built simultaneously
- **Workspace Isolation**: Each patch gets its own build workspace
- **Incremental Processing**: Only processes new patch-bug combinations
- **Resource Limits**: Configurable CPU and memory limits per build

### Monitoring
- **Build Status**: Real-time build progress reporting
- **Success Metrics**: Tracks repair success rates
- **Error Logging**: Comprehensive error reporting and debugging