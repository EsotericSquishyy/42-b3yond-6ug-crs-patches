# Predicates subgraph of SeedGen2

# Given coverage information (SeedFeedback), evaluate the predicates
from seedgen2.graphs.cotbot import CoT
from seedgen2.presets import SeedGen2GenerativeModel, SeedGen2InferModel
from seedgen2.graphs.sowbot import Sowbot
from seedgen2.utils.callgraph import get_current_callgraph, get_ancestors, get_successors
from seedgen2.utils.functions import FunctionInfo, locate_function
from seedgen2.utils.grpc import SeedD
from seedgen2.utils.seeds import SeedFeedback

from typing import List
import logging
import random

PROMPT_flip_predicate = """
Help me modify the python script that generates test cases.
I noticed that the current script does not generate test cases that cover a certain predicate.

In the file `{file_path}`, the predicate is in function `{function_name}`.
The predicate is: `{predicate}`, which value is always `{predicate_value}` in all the generated test cases from the current script.

I want to flip the predicate value so we can cover more branches.

Here is the current python script:
{script}

To help you find a way to flip the predicate value, I will also give you the source code of some functions related.

{related_functions}

You need to modify the script, so the test cases generated by the script will help flip the predicate value.
"""

PROMPT_flip_predicate_again = """
Help me modify the python script that generates test cases.
I noticed that the current script does not generate test cases that cover a certain predicate.

In the file `{file_path}`, the predicate is in function `{function_name}`.
The predicate is: `{predicate}`, which value is always `{predicate_value}` in all the generated test cases from the current script.

I want to flip the predicate value so we can cover more branches.

In last time, you did not successfully flip the predicate value.

For your information, here is the python script you wrote last time:
{script}

And here is the chain of thought you wrote last time:
{chain_of_thought}

Unfortunately, the plan did not work. So in this time, you need to write a script, focusing on details that you might have missed last time, and avoid making the same mistake again.

To help you write the script, I will also give you the source code of some functions related.

{related_functions}

You need to modify the script, so the test cases generated by the script will help flip the predicate value.
"""


def get_related_functions(seedd: SeedD, functions: List[FunctionInfo], harness_binary: str, target_function: str) -> str:
    G = get_current_callgraph(seedd, harness_binary)
    # in the call graph G, we need to find all the predecessors of the target function

    predecessors = get_ancestors(G, target_function)
    directed_children = get_successors(G, target_function)

    related_function_list = predecessors + \
        [target_function] + directed_children

    related_functions_loc = [locate_function(
        f, functions) for f in related_function_list]

    logging.info(
        f"Based on the callgraph, got {len(related_functions_loc)} related functions.")

    related_functions_source = [
        (f.name, seedd.get_region_source(
            f.file_path, f.start_line, f.start_column, f.end_line, f.end_column).source) for f in related_functions_loc if f is not None
    ]

    logging.info("Source code retrieved.")

    return "\n".join([f"Function `{name}`:\n{source}" for name, source in related_functions_source])


def improve_entrance_by_predicate(
    seedd: SeedD,
    script: str,
    seed_feedback: SeedFeedback,
    functions: List[FunctionInfo],
    harness_binary: str,
    N: int = 5
):
    """
    Attempts to flip a predicate by modifying the script up to N times.

    Parameters:
    - seedd: SeedD instance
    - script: Current Python script generating test cases
    - seed_feedback: SeedFeedback containing coverage information
    - functions: List of FunctionInfo objects
    - harness_binary: Path to the harness binary
    - N: Number of attempts to flip the predicate (default is 5)
    """
    # Find the entrance function (LLVMFuzzerTestOneInput)
    entrance_function = next(
        (func for func in seed_feedback.partially_covered_functions if func.function_name ==
         "LLVMFuzzerTestOneInput"),
        None
    )

    if entrance_function is None:
        logging.info("Entrance function is not found or is fully covered.")
        return

    # Get the list of partially covered predicates in the entrance function
    old_predicates = entrance_function.partially_covered_predicates

    # Randomly select one predicate to focus on
    predicate = random.choice(old_predicates)

    # Get related functions and predicate source code
    related_functions = get_related_functions(
        seedd, functions, harness_binary, entrance_function.function_name)
    predicate_source = seedd.get_region_source(
        entrance_function.file_path,
        predicate.start_line,
        predicate.start_column,
        predicate.end_line,
        predicate.end_column,
    )

    # Determine the current value of the predicate
    if predicate.true_count == 0 and predicate.false_count != 0:
        predicate_value = "False"
    elif predicate.true_count != 0 and predicate.false_count == 0:
        predicate_value = "True"
    else:
        predicate_value = None

    # Initialize the CoT model and Sowbot
    cot_model = CoT(
        model=SeedGen2GenerativeModel().model,
        json_model=SeedGen2GenerativeModel().json_model
    )
    sowbot = Sowbot(seedd, harness_binary, model=cot_model)

    # Initialize the script to be modified
    current_script = script

    # Attempt to flip the predicate value up to N times
    for attempt in range(1, N + 1):
        if attempt == 1:
            prompt = PROMPT_flip_predicate.format(
                file_path=entrance_function.file_path,
                function_name=entrance_function.function_name,
                predicate=predicate_source,
                predicate_value=predicate_value,
                script=current_script,
                related_functions=related_functions
            )
        else:
            prompt = PROMPT_flip_predicate_again.format(
                file_path=entrance_function.file_path,
                function_name=entrance_function.function_name,
                predicate=predicate_source,
                predicate_value=predicate_value,
                script=current_script,
                chain_of_thought="\n".join(cot_model.get_chain_of_thought()),
                related_functions=related_functions
            )

        # Use Sowbot to generate a new script attempting to flip the predicate
        sowbot_result = sowbot.run(prompt)

        # Update the script with the new version
        current_script = sowbot_result.generator_script

        # Get the new set of partially covered predicates
        new_predicates = None
        for func in sowbot_result.seed_evaluation_result.partially_covered_functions:
            if func.function_name == entrance_function.function_name:
                new_predicates = func.partially_covered_predicates
                break

        # Check if the predicate value has been flipped
        if new_predicates and new_predicates != old_predicates:
            logging.info("Successfully flipped the predicate value.")
            logging.info(f"Old predicates: {old_predicates}")
            logging.info(f"New predicates: {new_predicates}")
            return current_script

        logging.info(
            f"Attempt {attempt}/{N} failed to flip the predicate value.")

    logging.info(f"Failed to flip the predicate value after {N} attempts.")
    return current_script
